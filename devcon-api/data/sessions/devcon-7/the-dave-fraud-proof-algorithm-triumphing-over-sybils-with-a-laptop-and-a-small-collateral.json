{
  "id": "the-dave-fraud-proof-algorithm-triumphing-over-sybils-with-a-laptop-and-a-small-collateral",
  "sourceId": "C7ZFH3",
  "title": "The Dave fraud-proof algorithm â€” triumphing over Sybils with a laptop and a small collateral",
  "description": "Current fraud-proof algorithms are susceptible to Sybil attacks, impacting security, decentralization, and (settlement) liveness. This presentation introduces _Dave_, a novel algorithm that offers an unprecedented combination of these three properties. We demonstrate that there's no realistic Sybil attack capable of exhausting defenders' resources or causing significant delays, even with minimal bond requirements.",
  "track": "Layer 2",
  "type": "Talk",
  "expertise": "Expert",
  "audience": "Research",
  "featured": false,
  "doNotRecord": false,
  "tags": [
    "Optimistic rollups",
    "fraud",
    "proof",
    "Optimistic",
    "rollups"
  ],
  "keywords": [
    "Interactive",
    "fraud",
    "proofs"
  ],
  "duration": 1393,
  "language": "en",
  "sources_swarmHash": "f6b19521b73dd026fbdfe1a938aa2a58f1b3e9332c026eba6e6fdd0cc69e350a",
  "sources_youtubeId": "dI_3neyXVl0",
  "sources_ipfsHash": "",
  "sources_livepeerId": "",
  "sources_streamethId": null,
  "transcript_vtt": "https://streameth-develop.ams3.digitaloceanspaces.com/transcriptions/673430199dbb7a90e1d5c737.vtt",
  "transcript_text": " Tanya Cushman Reviewer:\"Presenter's note\": Hello, can you all hear me? Okay, I'm Gabriel. And today we're going to be talking fraud proofs, you know, like another session about fraud proofs. We will present a new technique that we've just published, in fact, so it's been in the oven for quite a while, and I'm quite excited to show it to you all. But the bottom line is that we weren't quite happy on the current set of fraud truths, so we created a new algorithm. So first I'd like to thank Cartesi for all the grants provided, and also my co-authors, Augusto, who is here on the audience, and Diego. So thank you all, and also to all the organizers of this amazing event. Yeah, so first I want to get this question out of the way, the ZK question. It may feel that when we're talking about fraud proofs, that we're trying to figure out the best grass to feed our horses, and I want to push back against that notion, you know, because there are no silver bullets. You know, ZK is not panacea. When you compare them with front roofs, there's a sharp contrast in throughput and costs, which means that depending on the application, you're going to prefer the different algorithms, you know, there are going to be trade-offs in the end. There's no silver bullets. That's the point I wanted to get across. for the different algorithms. There are going to be trade-offs in the end. There's no silver bullets. That's the point I wanted to get across. So now let's focus on fraud proofs. Yeah. The agenda today is that they're actually quite hard to get. I hope you got that notion from Luca's talk. All the previous attempts were either unsafe, centralized, or slow, and Dave is not. Yeah, so fraud proofs are in a difficult position right now. So we have the pressure, you know, on the top there's Vitalik's tweet, essentially calling for stricter standards, but if we look at L2B, we don't see full pizzas, right? So we have the pressure, but we don't have implementations coming. And the reason for that is because it's actually quite hard to get fraud proofs right. And the reason for that is because it's actually quite hard to get fraud proofs right. And by right, I mean essentially three properties. The first, we're there. I want you to be able to become a validator. I want you to be able to go there without a supercomputer, without huge bonds, and be able to participate in the consensus, in the protocol. And the second property is that I want that you be able to participate in the consensus, in the protocol. And the second property is that I want that you be able to defeat anyone by yourself, even if you're facing against a nation state. So if you get those two properties to defend an optimistic roll-up, all you have to do is set up a node on your own infrastructure. You don't need to delegate trust to anybody else. We inherit the security of the base layer. So those are like the two, like, one event property, and we want it to be decentralized. And the next one is that we want settlement to happen without large delays. We want settlement to happen quickly. So let me run all the three of them together. They kind of look like this. You know, decentralization. I want you to be able to participate without a supercomputer or huge bonds. There's security, which means the TVL cannot be stolen, even if you're facing against this nation state. And liveness. No large delays. And you might be getting some flashbacks, you know, like some PTSD, like, oh, no, do we have another trilemma? And, yeah, kind of, you know. It's actually quite hard to get the three of them at the same time. And you can always naively go from one vertex to the other. But you sacrifice one to gain the other. So you can't take this straight off. So it does look like a real trilemma. And the reason for that is Sybil attacks. I will zoom in on only the first one, which is resource exhaustion attacks. It's like a spam attack where you create a huge number of Sybils and you just drain the funds of the honest validator until they can no longer participate in the game and then you can steal the TVL. So this is a Sybil attack that targets the security of the algorithm. And there are mitigation strategies, but they end up restricting participation and thus harming decentralization. So there are three main solutions that we will talk today. There are several others, but we'll talk about these two. The first two is by Optimism, Optimism Fault Proof. There's also Arbitrum's Bold. And our own permissionless referee tournaments, PRT for short. This is the previous algorithm we did. That was our first attempt at cracking this. And I want to highlight the very important fact that the top two, you know, the first two, if you look at the TVL distribution on L2Beat, pretty much most of it is being protected by those first two. You know, it's either an OP chain or an arbitrage chain. So we need to keep this in mind because we need to take the analysis of these algorithms quite seriously. So this is a sneak peek comparison between, you know, those three and the one we're going to present today. And the columns, they map directly to those three properties. So, for example, bonds, if you look at bold, you need 3,600 ETH to become a validator. So it's a very high bond value. And this has a centralization effect. So the bond column is related to centralization, decentralization. Now, expenses. Oh, just to,, just to highlight this. This is a one million Ether attack scenario. So we assume that the adversary is willing to burn that amount of money. In that case, if it's a OP fault proof, the defender has to match those funds. So if you don't have also one million Ether, you will lose that EVL. So that column expenses maps to security 1 million Ether, you will lose that CVL. So that column expenses maps to security. And finally, we have delay. If you look at our own, if there's this 1 million Ether attack, you get 20 weeks delay, which is also quite high. So none of the three we feel are quite adequate. And today we will present Dave, which is on the bottom, which strikes a good balance across all three of them. Cool. So let's talk about some basic concepts of fraud proofs. Okay, so first our threat model. We assume that the layer one works. However, we also assume that it can be censored for up to one week. So think like a censorship budget that the adversary has, and they can spend it at will. And we also assume there is one honest validator, which we're going to say it's Willy. And Willy has a laptop, a few ether, and values, hard values. So we begin with the basic primitive, which is a pairwise refutation. So, the goal is that, well, you have two players. You have your Willy, the adversary, and the blockchain acting as a referee in the middle. And those two will engage in a dispute to prove that the other is wrong. And in the end, the goal is to prove the result of a program to the referee. And it's interesting because they don't prove the correct result directly. They prove that the other is incorrect. And since we assume Will is there, he's the one who's going to enforce the right result. Because he's the honest one, you know. Yeah, so they're going to fight to prove the correct result of a program. Now, what do we mean by program? The computation model has an initial state and a state transition function, agreed by everyone, and then we apply the state transition function over and over the initial state until we get the final state. And that final state is the result of the program. That's what we are trying to prove to the blockchain. And the intuition of a refutation game is that first we're going to perform a binary search on this computation and try to pinpoint the exact state transition that they first disagreed on. Because if they agree before and disagree after, somewhere in the middle, they started disagreeing. And we want to pinpoint exactly that, and once you find that divergence, you can execute a single state transition function, you know, the referee, the blockchain, and figure out who's lying and eliminate this liar. So this is the basic intuition, but we're going to make a slight change to this. So instead of committing just to the final state, which is really what we're interested about, we are going instead to make a commitment on the whole history of the computation. So we have all these transient states and we're going to commit to that. So it's like a Merkle tree where the leaves are all the transient states. We Merkle-ize that, we get the claim, so we turn the dispute not just on the final state but also on the history. And this change is important because we remove the possibility of false flag attacks, which are quite annoying, you know? So we can join claims that are the same together on the same thing. And this enables a whole bunch of algorithms, including PRT, because we introduced this technique on PRT, and Dave, which we're going to present today. Now, the final piece, to get all the primitives, is deadlines, because it's an interactive protocol. So players act in turns, and if they refuse to act, we need to do something. So we need to set deadlines to eliminate players who are not cooperating. But remember, we have the one-week censorship in our threat model. So naively, we would have to set a one-week for each interaction, which would kill the liveness of any protocol. So what we instead do, this is a technique that many protocols use, is something like a chess clock. So this allows you to amortize this one week across many interactions instead of having to pay it for every single interaction. So you turn from the seven-day multiplying each interaction for it to be an additive part of the expression. And then you only need to pay for each interaction the real time of that interaction in the absence of censorship. Because an interaction is quite fast. It's like five minutes. And we don't want to pay on top of that five minutes seven days. So we use the chess clock to amortize that. Now let's generalize this. This is a pairwise refutation first. Now let's do a multi-party refutation. And there are two high-level approaches. One is the parallel approach, which is more like what Bold uses. And the good part of it is that it finishes fast. So we have Willy engaging every other claim in parallel at the same time. But the problem is that we incurred a chance of overwhelming Willy, right? So imagine that instead of only five, we had like one million Sybils. We'd have Willy trying to fight everybody at the same time, and he could get overwhelmed and lose and lose a TVL. So we have this, you know, oh, it's fast, but it might overwhelm Willy. And we can mitigate that by increasing bonds, but then we start centralizing the algorithm. With PRT, which is our previous algorithm, we went a different route. We used this tournament idea, right? So we put symbols to fight against other symbols. So the number of rounds is logarithmic, the expenses are logarithmic, and the delay is logarithmic. So this all means exponential advantage. Willy has an exponential advantage on delay and resources. But each round takes a week because of the censorship. You know, even amortizing the week across a match, every match, every round still has to last at least a week. So if we imagine this, the analogous of one million symbols here, there will be 20 rounds. So it will take 20 weeks, which is high, you know? But matches only take two hours in practice. In the absence of censorship, they would take two hours. But because there could be censorship, we need to add the week. So we were thinking, oh, why don't we try to amortize this one week, not only inside a single round, but across the entire dispute. So this is what we'll try to do. So what I'll present now is an attempt to accomplish that. Okay, so the algorithm is called DAVE, and it's just DAVE. It's not an acronym. It's based on the David versus Goliath archetype. Because, anyway. So the first change we make is we change the tournament to a repechage tournament. This is a fancy name just to mean matches are not eliminatory. You don't eliminate a claim as soon as it loses. You give it a while. It has to lose multiple times before it's finally eliminated. So this is what repressage means. Now don't try to think about how long this will take. Forget that. Let's just think on the soundness of it. I want on this slide to convince you that Willy won't lose and he will defeat everybody. Let's think about time later. So imagine that we have the censorship of one week, but we reduce the rounds, the matches to one day. So every one day Dave rematches everybody, including Willy, and then they fight. The next day, rematches everybody again, and so on. We know that Willy can't lose unless there's censorship, but even if there's censorship, we know that Willy can't lose more than seven times because the budget is only seven days. So it's like Willy has eight hit points, but the adversary has only seven bullets. So the best the adversary can do is spend his whole budget and force Willy to lose seven hit points. And then he's out of budget. And now Willy is very angry indeed and is going to kill everybody else. Now this may seem a bit abstract, so let's get it more concrete. So this is a different example. The previous one was with eight hit points. This one is just three. The optimal value is more like 21, you know, but it's hard to visualize that. So let's go with three first. Yeah, so everybody's on the same bucket in the beginning. Everyone has three HP. And the white arrows point to the matchmaking. So Willy is paired against red, and green is paired against gray. So red and green lose, so they are demoted. Then we rematch again. Now this time Willy is against gray, red is against green. So green loses, gray loses, and it keeps going like this, you know, this logic of pairing whoever loses gets demoted. And eventually, Willy wins, you know, he kills everyone. But on this example note that we assume there's no censorship, so Willy didn't lose any hearts. He could have lost hearts, but it's, you know, it would take more images to do that. So we're just assuming that there's no censorship for this figure. But there could be. So Willy could lose two rounds, but not the third one. But we didn't talk about how this matchmaking is done. And this is quite delicate, in fact. This is at the heart of Dave, the matchmaking. We can't do it randomly. We cannot do this adversarially, Byzantine, you know. It has to be done in a very specific way, which is we need to do matchmaking by hit point. So we want to match the same hit point with same hit point, or at least as close as possible. So looking back, it's the same image, you know. We did the correct matchmaking. So on the second round, Dave is matched, not Dave, Willie. Willie is matched against the gray one. He's not matched against red or green. Has to be matched with gray. Third round is not possible to do a perfect pairing. So we do our best. And our best would be either gray or red. And so on. So like abstractly, it's like as if we sorted every claim by hit point, highest to lowest, and then we'd match them left to right. Yeah, and when we do that, we actually get exactly what we wanted. You know, if it was random, there would be no improvements over PRT. But if we do the rematching with similar HP, we actually dilute the seven days across the whole dispute. We get exactly what we wanted. There's some constants there. That's why I said proportional. It's not exactly that. But the idea is really we are amortizing seven days across the whole dispute. And we're only paying one day in that seven day example you know that I gave earlier times logarithmic of symbols. I mean the real values is actually more like 10 hours you know then there's a constant. We go on all of that for a lot more nuance and discussions on the paper so we can check it out. Yeah so this finishes the description of Dave. So it's a repashage tournament where we do the matchmaking with similar HP. And when we do that, we amortize the seven days across the whole dispute instead of over a single round. So concluding, you can be Willy. You only need the laptop and about a three-eater collateral. You can defeat anyone because you have this exponential advantage. So this means that a roll-up that uses Dave inherits the security of L1. And for any realistic Sybil attacks, it's going to take no more than four weeks. It's going to be within four weeks. And thus Dave triumphed over the Sybils with a laptop and a small collector. But Dave had no supercomputers on his hands. And we got those results. Yeah, that's all I had to present to you today. Thank you very much for coming. Great talk. Love the name Dave. Thank you. He's got a few Q&A questions. He can still add some of the questions while we're going through some of these and upvote them. But the first question is one that I've been thinking too. What if there's multiple willies defending? Won't they eliminate each other? Yeah, so that's a good question. When we did the computation hash, which is that commitment, it means that everybody that's honest is going to be on the same team. So if there are many willies, they will fight together against the symbols, not against each other, because they claim the same thing. So we have this uniqueness of claims when we do the computation hash, and we allow all the honest validators to join teams. So we consider this singleton hero, it's just Willy, but in practice there are going to be many Willys and they all fight together pushing in the same direction. Cool. Next question is about your censorship model. Is your censorship model hard censorship? And do inclusion lists improve these things? Yeah, so the inclusion lists, I don't think they help exactly on that. So the censorship model, you know, Luca gave a very good intuition of it, is that seven days is the time we can try to organize a hard fork. So suppose there is hard censorship. My transactions are not getting to the blockchain. So what's going to happen is that, you is that Twitter is going to catch on fire and going to scream to everybody, look, I'm being censored for already four days. Everybody is going to get iffy about this and we are going to together organize like a hard fork or something to fix this. So the point is not that there can't be a seven-day censorship. It is that if there is a seven-week censorship, the Ethereum community will together realize and say that this is a problem and then hard fork away. And if we put like a one-day censorship, I would convince nobody. Seven days, it's the threshold that we consider to be easy to convince. Cool. The next question. What happens to levels in the current PRT? Will your plans be to eliminate it with a ZK? Yeah, exactly. So PRT, if you look at our current implementation, we are doing it with three levels. We think with some really good engineering effort, we can do it in two. We want to do it in one using ZK. Exactly that. And this is a prerequisite of Dave. So Dave already assumes that we managed to reduce this to one level. Cool. So what happens if you mix algorithms together? Would that increase security? Do you see it working? Yeah. So there are two ways to mix algorithms. One of them is to improve liveness actually. So PRT finishes faster if there are very few number of symbols. So what we could do is launch PRT in parallel with Dave. If there are very few symbols, PRT finishes first. If there are a lot of symbols, Dave finishes first. So then we take whoever answers first. So this is an approach to improve on liveness. Now, to improve on security, we can also mix them with the goal of reducing the risk of a bug. So we could have a consortium, like a quorum of four members. One member could be PRT, but permissioned. So permissioned PRT, but permissioned. So permissioned PRT has no problems of liveness, so we could have that one of the members in the forum. Then we could have Dave as another member in the forum. Then we could have, I don't know, a TEE or a quorum of TEEs, and then we could have a multisig, you know? So if we have this quorum of many, it would take a lot of effort to try to corrupt all of them at the same time. So we reduce the risk by reducing the chance of there being a bug. So that's how you could mix protocols. Cool. So what if the goal is not to disrupt the chain, but just to delay the chain? How large would the cost be if the attacker presuming the only goal is to delay by four weeks? So if you want to delay by four weeks, I think you need more than $10 billion or something. We have to burn the GDP of Japan. It's crazy. We sometimes lose sight of exponential or logarithmic. So really, if you burn trillions, you can't even fit that on the blockchain, then you couldn't really push past these four or five weeks. The next one, asymptotically is it still logarithmatic delay, right? Yeah, exactly. What we did is we reduced the constant multiplying it by about one order of magnitude. Okay. We have multiple willies that are good, but then I decide to go bad. They can't because when they do a bisection, they need to provide the Merkle proof, and the proofs won't just match. They'll just not match. Cool. All right. Everyone clap your hands for Gabriel and thank him for his time he spent on this talk. Thank you so much. The next session will be at 11.30.",
  "eventId": "devcon-7",
  "slot_start": 1731470400000,
  "slot_end": 1731472200000,
  "slot_roomId": "stage-5",
  "resources_presentation": "https://docs.google.com/presentation/d/1GhOQePXCr0xuShvpJcgSNAMhIC_wT2B34JYiogZJB7s",
  "resources_slides": null,
  "speakers": [
    "gabriel-coutinho-de-paula",
    "augusto-teixeira"
  ]
}