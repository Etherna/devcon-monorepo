{
  "id": "zk-email-fast-proofs-and-production-ready-account-recovery",
  "sourceId": "WNQBQH",
  "title": "ZK Email: Fast Proofs and Production-Ready Account Recovery",
  "description": "We discuss progress that ZK Email has made in making new proofs really easily, as well as interesting new on-chain directions for email-triggered transactions. We'll go over proof registries, email-based multisig signers, and email guardians for account recovery in production.",
  "track": "Applied Cryptography",
  "type": "Talk",
  "expertise": "Intermediate",
  "audience": "Engineering",
  "featured": false,
  "doNotRecord": false,
  "tags": [
    "Privacy",
    "ZKP",
    "Use cases of cryptography",
    "client-side",
    "2FA",
    "Account Abstraction",
    "Cryptography",
    "Identity",
    "Privacy",
    "Recovery",
    "Security",
    "Use cases of cryptography",
    "Zero-Knowledge",
    "ZKP"
  ],
  "keywords": [
    "ZK",
    "Email"
  ],
  "duration": 1518,
  "language": "en",
  "sources_swarmHash": "",
  "sources_youtubeId": "YvzdNMpynZM",
  "sources_ipfsHash": "",
  "sources_livepeerId": "",
  "sources_streamethId": null,
  "transcript_vtt": "https://streameth-develop.ams3.digitaloceanspaces.com/transcriptions/6734245e9dbb7a90e18aa264.vtt",
  "transcript_text": " Today we'll mostly be talking about zkEmail, new applications, and production-ready account recovery. I'm Ayush. I'm Soran. And most of this work was only made possible because of this incredible team of folks we have working with us. So huge shout out to them. So we'll start by mostly going over the basics. What is ZK email? How does it work? Then we'll dive a little bit into how you can make proofs really easily. And we'll discuss a new registry in SDK that lets you do that. And we'll try to expand the possibilities for how you think ZK email proofs can be used in reality. Finally, we'll talk about account recovery and how you can generally have email-triggered transactions on-chain. And last, we'll talk about dev tooling. All the different ways that we've put together tools for people to build these kinds of proofs really easily into existing apps. So to start with the basics, what is ZK email? The idea is that emails are signed according to the DKIM protocol, an RSA signature of the SHA-256 of the content of the email. This is applied to every single email sent or received since 2017, usually used for spam filtration, but we prove this inside of a ZK proof and add selective disclosure and parsing. This means that we can get proofs of emails where we can get privacy, as in we can hide or reveal whatever we want. We get provenance. We can verify the data from the Web2 services mail server directly, and it's portable. We can verify it directly on chain, on any chain that can verify these proofs. You can imagine the simplest intuition for this is something like whistleblowing. We take an email you've already received and we redact different parts of the email and then we prove that the email was still valid or sent by the source. But you can do much more than this. For instance, zkp2p builds marketplaces on top of these emails. One example is a domain marketplace. The idea is that you can take any Namecheap domain that you own, and you can list it on this marketplace, and when you sell the domain to somebody, aka you transfer it to them, both of you receive a confirmation email from Namecheap automatically. If you prove that confirmation email on-chain, you can then unlock escrowed money directly to pay for that domain. This is quite compelling, and the idea that you can interoperate these Web2 assets or things in the real world with things on-chain is extremely compelling, and how can we get more of these? So our idea was, what if we made it really, really easy for somebody to create new proofs and update those proofs? So we'll talk a little bit about how this can be applied to general proof infrastructure in a couple of different ways. A registry that lets you reuse proofs that other people have already defined and define new ones very easily. An SDK that lets you use them very easily in your application. And finally, some inspiration on what are some apps that people are actually building with this. So one of the main problems with ZK development today is that an app developer who's trying to build something related to their email should not have to think about the nitty-gritty details of which proof system they're using and the different trade-offs and different systems. So the idea is you can abstract this all away. You just define a sort of a blueprint, like, oh, I want to prove that I was rejected from giving a DevCon talk, for instance. And then if I define this kind of blueprint, anybody can use it without having to think of the proof system that's happening in the background. How does this work? The idea is you can create new patterns very easily. For instance, after naming your pattern and uploading a sample email, we can automatically parse out the relevant information from that email to help define this new kind of pattern. For instance, we can take out the sender domain automatically or things like the email length of the header or the body. Then we have this nice feature where because we want to define a regex to extract specific information from within that email, we automatically throw an AI on top of that raw email data and define that regex for users. We found that historically this has been a bit of a roadblock because having to adapt regexes to odd different kinds of email templates is often not a very intuitive task, but we're hoping this makes it super easy for anyone to define a new kind of proof with no relevant ZK or necessarily even parsing experience. And finally, it'll give you a configuration like this. This is a decent amount of text, but the main thing to take away from this is that it's only about 20 or 25 lines. This defines all of your regexes, where they occur, and who the email was sent from, and other metadata about it. But this is a full encapsulation and definition of your proof. Then in the background, we can automatically compile this to all the proof systems that we listed. Right now we have Sircom and Noir Incoming and also ZKVMs. And once it's completed, the compilation is completed, we automatically will deploy an interface that anybody can use to create this proof. We see this kind of like almost like a bit of a Vercel. You can sort of create your proof and deploy it without having to think about any of the infrastructure behind the scenes. Concretely, for instance, for the proof of DevCon rejection, you will automatically get an interface for you where you can automatically sign in with your email and then it will fetch the relevant emails that might possibly satisfy this proof. We can filter those emails entirely client-sized so that our server never sees those emails, and then let the user choose the proof they want to select to make a proof of. In this case, for instance, for GitHub, for DevCon, you can choose one of the specific DevCon rejection emails. For GitHub, you could choose, for instance, a GitHub username email to let you prove your GitHub username. Finally, the proof can happen in the background, and you can share that proof out to whoever you want to share. And we also show you the metadata very clearly and even let you look at the raw proof. The idea is that once we have these kinds of definitions, we can expand this even one step further. We can also kind of treat it like a bit of a GitHub, where each of these configurations can be edited and modified by other people, and you maintain a version history. So for instance, you can imagine that each of these patterns come with versions depending on email templates as they change, or users as they want to parse different kinds of things. And if you decide, hey, I don't like this pattern, I want to replace it with a different one, say I want to take my DevCon rejection email, and instead I want to prove DevCon acceptance, I can just fork it, change that value, and recompile it. And so we see these kinds of flows that developers are very used to also being useful for general people to be able to create these new kinds of proofs. You can try this out live if you go to registry.zk.email. We've put a QR code up. You can define a new proof by logging in and then creating a new pattern or trying any of the existing ones within the interface. Note that there will probably be a decent amount of load as all the folks in the audience try this, but we will have a workshop tomorrow where we go through detail, step-by-step, how exactly to do this. Now, if you want to integrate this into an actual application, again, you don't need to read the code, but just the idea that this can just be three or four lines, someone can just define, this is the kind of blueprint that I want to prove within my app. In this case, the DevCon rejection proof. They can say if they want to be local or not, and then they can, again you don't have to read the code, but they can just generate the proof and verify it on-chain if they want without having to think about the proof system. We've seen people build a lot of really exciting stuff with just this primitive. For instance, folks have built proof of DocuSign or HelloSign where you prove you signed some document with some title from somebody. You can prove you took a flight to or from somewhere and only reveal where you took it from and the destination. Someone created this proof where you can prove you're part of a Slack workspace. You can now start seeing how these things might start combining. You can build a system where you prove you're part of an organization on Slack, and then you automatically get reimbursed for your flights by proving you took them. And as people start realizing, oh, you can bolt these things together, you can build actually interesting systems on chain where you combine different facets of ideas or identities or actions we've taken in the real world. People have also proved, for instance, you've exported your LinkedIn data, which they then sell to, for instance, OpenAI to train on. You can then prove you exported all of your OpenAI chat data and then sell it to, for instance, Anthropic. You can also prove you automatically resolve the GitHub issue and then automatically disperse contributors for their contributions. John did this fun proof where you can prove you ordered a Pad Thai in Thailand where you basically show you have a grab receipt which has the word Pad Thai on it and a location that's in Thailand. And of course, you can prove that your proposal was rejected from DEF CON. So now that we have all of these basic concepts around how you can make proofs of emails that you've received in your inbox, one might imagine that you can also make proofs directly on chain. So far, we've just talked about identity that already exists in Web 2.0. But emails, you can imagine, are an interesting interface to actually interact with on-chain. So far we've just talked about parts of your identity that already exist in Web2, but emails you can imagine are an interesting interface to actually interact with on-chain apps directly. So concretely, how might you get this new kind of email trigger transaction? Well the idea is that instead of doing what we were doing earlier where you log in with email for instance and you select one to make a proof of, you instead send an email to trigger a transaction on-chain. This is quite interesting because now you can have a smart contract that's directly gated just by a sent email. This primitive is quite powerful. You can build things like account recovery, for instance, where you add emails as wallet guardians directly on your existing smart accounts. Things like email signers, where you can add an email directly on your multi-sig and have that approve transactions, for instance, as a 2FA, or for folks who don't have EOA wallets to be able to still approve transactions. You can log in with emails. This is something folks have wanted in the ecosystem for a very long time. But the idea that you can interact with, for average, application or crypto app just by logging in with your email and then using that to authorize an ephemeral session key. Or an email wallet where you can receive assets directly to email addresses even if they've never signed up. But today, we'll mostly focus on, I guess to start with, exactly how we can do these kinds of smart contracts with emails. So for instance, the flow here is that users can receive some email asking them to trigger some kind of transaction. And by replying to it, they can initiate that transaction on-chain. They will receive an email kind of like this. We've moved the actual value that's getting approved to the subject, so it's easy for you to read. But the idea is that you would receive a command kind of like recover account eth address from old owner eth address to new owner eth address. In reality, users would just see a simulation in their email, not this text, but we've put it here so it's easy to read. And the idea is that by replying to this email, they're effectively signing this message, which can then be used to send on-chain. Flow here is that a user will try to trigger some sort of transaction, a relayer will send them an email. When they reply to that email, action is then sent directly by the relayer on-chain as they make a ZK proof of that action. One of the cool properties of this is the idea that we have this account code for both privacy and decentralization. You can kind of see, again, we've elevated it into the subject here, but normally this would just be embedded into the body where the user doesn't have to think about it. But what is the point of this long hex string? It's not really private key or something we're necessarily exactly used to. And anyway, it's abstracted away from the user. But it is nice because this value gives us direct email address privacy on-chain. We never reveal the email address, we only ever reveal a hash of the email address and that code. We can also prove availability to the user in this email. That is, concretely, we can ensure that the access to the user's account cannot be withheld by us going malicious, because as long as they have the account code, they can still transact with that email contract. And finally, it allows for relayer decentralization. Anyone can run this kind of system, can run email servers that send out emails, receive replies, and then trigger transactions on-chain. You can imagine this can happen via email replies, as it does right now, or even directly via Google logins. The difference between these is mostly basic security. For instance, on the left side, you can show concrete simulation data to the user of what they're signing. For Google sign-in, it's more like a blind sign-in and a blind signature. But the idea is that applications can choose whatever they want based on what is most convenient for them. Okay, so from now, amongst the products using email trigger transactions, here we introduce the details of the email account recovery. So in short, using email account recovery, you can specify anywhere with an email address as a guardian for your wallet. And when you lose access to your private key, this guardian can help recover your account just by sending emails. And in this way, this achieves a similar UX as a bank account or PayPal, such that users can reset passwords from their email account. And we also believe the combination of the email account recovery with the PASC wallet makes a super easy wallet UX because PASC allows users to sign transactions through the face ID and so on. And when users lose a device, users can use email account recovery to recover users recovery user's account on the other device. So from now, we explain the details of how email account details of how email account recovery works with showing the UI of the email account recovery feature in the Clive wallet we are building now. So in the first step, the user configures recovery settings, such as Guardian information. So in the Clave URL, the user just needs to specify the Guardian's email address, like this one. So in the second step, the Guardian will accept this request. So the Guardian will receive an email like this one from the relayer, and if the guardian can approve this request, the guardian just need to reply to this email. And the guardian will finally receive a confirmation email like this one. And in this process, our guardian actually generates ZK proof of the guardian's email, and send this email proof on-chain to register Guardian's address. And once the user loses access to the private key, we actually start the recovery process. So in this process, the user puts the Guardian's email address again, and the Guardian will receive an email from the layer in the same way. And if the Guardian approves this recovery request, the Guardian will reply to this email and receive the confirmation email. And in this process, the layer similarly generates ZK proof of the Guardian's email. In the final step, the Guardian, the wallet user, can complete this recovery request once more than a threshold number of the Guardian's upload recovery request. However, there is a time delay before completing this recovery request. And this improves the security when the Guardian's email account is hacked, because the wallet user can cancel recovery requests if the email account is hacked. So in this way, we can keep the security and the accessibility of the user's account as long as the user can access to the private key or the Guardian's email account is honest. Sweet. So we have those account recovery deployments audited and live on mainnet for both Clave, which we'll roll out in the Clave wallet over the next week for PASCII wallets, and also in our recovery UI for safes. But this can be larger than just a couple of wallets. The idea is that any smart wallet can integrate this into their wallet. And so we've created a bunch of dev tooling to make it really easy for anybody to use these kinds of proofs. Concretely, for instance, a recovery module is a 7579 compatible smart account standard. This means any wallet is really easy to integrate with this specific account recovery. And even if you're not 7579 compatible, it's still quite easy to add account recovery to your wallet. We have a set of very simple APIs that users can call. Again, you don't need to read all the details here. But to trigger each of these requests, you can simply hit each of those APIs, and your own wallet or your own application can trigger any of these kinds of transactions directly. And finally, installing it to any kind of wallet in a front-end is also very easy. Again, you don't have to read the exact code, but just the idea that installation is just five lines in, for instance, the permissionless JS smart wallet creation interface. You can read more about it on our docs on the right side, and we'll have more links at the end. If you want to define your own kinds of proofs, not account recovery, but say any of the other application ideas, you can define your own kind of pattern in Solidity directly. Here we show that you can say something like recover account ETH address to new owner ETH address. Once you've defined this kind of Solidity code, you can then hit any API that any relayer has deployed. The API request looks kind of like this. Again, the main thing here is it's just about 10 lines, and it'll automatically handle sending the emails for you, getting the response, making the ZK proof, and sending it on-chain. You can see, again, these docs for how exactly to build with this dev tooling over here, and we'll have a workshop tomorrow where we go over more of it in detail. So, for instance, you can imagine this abstraction can be used to build account recovery, email signers, login, and the email wallet primitive we talked about in the beginning, but we're excited for folks to explore with these kind of email trigger transactions to build more different kinds of things. So just to quickly recap, we went over the very basics of how ZK email works and simple kinds of proofs you can make, how to make new kinds of proofs very easily and access them from a shared registry. Then, switching from making proofs of received emails to making new kinds of proofs very easily and access them from a shared registry, then switching from making proofs of received emails to making proofs of sent emails, we went over how you can do email trigger transactions, and then account recovery, and finally how we've made this really easy for new folks to either directly use or integrate directly into their wallets or projects, etc. We're super excited to jam more with folks. If people want, we'll have some booths specified on the left. You can catch us there after this talk and also over the next two days. And if you want to learn more about how to specifically use these tools in your applications, we'll have a concrete workshop tomorrow at 1.30 p.m. where we go over how to actually integrate each of these things directly with help from the team who actually built it. Sweet. So if you want to read, see, or hear more, we recommend following our Twitter on the left side, looking at our home page in the middle on zk.email. And if you want to view an original copy of these slides, you can scan the QR code on the rightmost side. Sweet. Thank you for coming, and we'll take some questions. Sweet. Thank you, Ayush and Sora. That was a very interesting talk, by the way, right? Yeah, I like to see ZKPs being used for something else rather than ZK all apps, right? And it makes us both Web 2 and Web 3. So we have some time for Q&A. So how about we take the first one? So it says, what zkp framework you are using and why? Yeah, it's a good question. So we've used and benchmarked all of the frameworks that we kind of listed in the beginning. We have versions in Surcom and now Noir and also now in ZKVMs like SP1 and RISC-0. We generally, so because most of these things are happening on, for instance, mainnets, we want to make sure that there's both high security and extremely high speed. So currently we use Surcom on the server side and also on the client side just because it's kind of the main one that's very mainnet ready right now, and also can prove extremely fast on the server side, and within like five to ten seconds usually for most of the proofs we're talking about. But we intend to work closer with Noir to get those client side proofs working in Noir, and closer with the ZKVMs to get much more extensible proofs on the server side. Yeah, that makes sense. Actually, by the way, you can upvote the questions so that we can see those that you upvoted first here on the screen. So maybe if we take the second one, would trusted setup ceremonies ever be required? If so, when? Yeah, so this sort of depends on the exact proof system you're using. If you're using the CIRCOM proof system we have in production right now, then yes, you will need to do a trusted setup. However, if you use the Noir system on the client side we're moving to, or the ZKVM system on the server side that we also have, then you won't need to do a trusted setup for that specific circuit. Yeah, so we have two votes. Yeah, maybe this question. So is there any prerequirements for an email to be ZK-approved? Not really. Any email you send to receive can usually be ZK-approved because all emails require this DKIM signature to go through spam filtration. There are some restrictions, like, for instance, Hotmail is not exactly pursuant to the standards, so something that you can't access a two-email within a Hotmail is not exactly pursuant to the standards, so some things that you can't access to email within a Hotmail email. But in general, almost every email that you send or receive can be approved. Okay, gotcha. I think we've still got time for more questions. Yeah. Yeah, maybe this one, when we consider... I think we can see them also here. I guess the top one, is there a key rotation problem? Yeah, so the public keys that the verification actually happens with are rotated every maybe six months to two years. For some folks, it never rotates. The nice thing about this is that the smart contract that holds those keys is publicly auditable. Anybody can go in and say, yep, this is the key that my DNS is fetching as well. But yes, to relay those keys on publicly auditable. Anybody can go in and say, yep, this is the keys that my DNS is fetching as well. But yes, to relay those keys on-chain, there has to be some sort of a system of oracles. In our case, we use like a specific multi-sig in which all of the, like a bunch of autonomous computers are calculating those and putting it on-chain. You can also doubly verify TLS notary or TLS proxies to ensure that all those values are correct. The important thing here is that you can use a single public value, that DNS value, to verify private data. And that public value is auditable. So the idea is that if there was ever some fault, somebody pushed malicious keys, there are enough time locks built into the system and also ways to stop it or ways to override those key registries for each user that we think this is not actually that big of a problem in practice. That makes sense. Thank you for the detailed question. Yeah, so maybe what if we take this one? Since DKIM private keys for the whole domain rather than the percenter, presumably the security model relies and we don't see the question anymore. Yeah, so, so... I mean, I'm just repeating the question for the live stream so that people, yeah, so the origin MTA preventing sender spoofing within the domain. Yeah, so the idea here is that yes, because you're only verifying the signature from the domain, you are trusting that that specific domain is, in fact, disambiguating senders correctly. The nice thing here is that most email providers that most people use, like Gmail, Outlook, iCloud, et cetera, definitely have this in by default because it would be very bad if they didn't. But we have noticed that some folks don't. So, for instance, we disable most .edu domains from most of these models because often they don't have very good parsing of this kind of which sender exactly in the domain sent that email. But in most cases, for instance, that you receive an email from Twitter or DevCon or whatever, usually you can constrain exactly the email address that sent it, and that's usually good enough. And they're usually using something like Google Workspace, so it's usually good enough, and they're usually using something like Google Workspace, so it's usually possible. And in the context of the email trigger transactions, while this depends on the private key of the specific email or Deacon or server like Gmail, we believe this achieves a better trade-off between the UX and the security. Thank you. So I think we are on time. Please thank again Ayush and Sora and please applaud them for their talk.",
  "eventId": "devcon-7",
  "slot_start": 1731468600000,
  "slot_end": 1731470400000,
  "slot_roomId": "stage-3",
  "resources_presentation": "https://docs.google.com/presentation/d/1G6_OH46sVVpOgDR1P1ZWqOpTtRzjcESBO1p9aHuVisY",
  "resources_slides": null,
  "speakers": [
    "aayush-gupta",
    "sora-suegami"
  ]
}