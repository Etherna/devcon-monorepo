{
  "id": "elliptic-curves-and-snarks-past-present-and-future",
  "sourceId": "Y3PMMA",
  "title": "Elliptic curves and SNARKs: past, present and future.",
  "description": "Elliptic curves are used in many proof systems. Some systems (e.g. Bulletproofs) use plain curves (e.g. ed25519). Some (e.g. Groth16, KZG-PLONK) use pairing-friendly curves (e.g. BLS12-381). Some recursive systems require pairing-friendly 2-cycle (e.g. MNT4/6) or 2-chains (e.g. BLS12-377/BW6-761). Some other recursive/folding systems require plain 2-cycle (e.g. Pasta). In this talk we will go through the difference between these curves and why there isn't a silver bullet curve for all scenarios.",
  "track": "Applied Cryptography",
  "type": "Talk",
  "expertise": "Intermediate",
  "audience": "Engineering",
  "featured": false,
  "doNotRecord": false,
  "tags": [
    "ZKP",
    "Cryptography",
    "SNARK",
    "elliptic",
    "curves",
    "Cryptography",
    "SNARK",
    "ZKP"
  ],
  "keywords": [
    "elliptic",
    "curves"
  ],
  "duration": 1518,
  "language": "en",
  "sources_swarmHash": "d418d4f93106c8a1c844d7ddadd6ef00204c7d15d551d1e3a9732f82c007bf46",
  "sources_youtubeId": "Bey043R_52k",
  "sources_ipfsHash": "",
  "sources_livepeerId": "",
  "sources_streamethId": null,
  "transcript_vtt": "https://streameth-develop.ams3.digitaloceanspaces.com/transcriptions/67335bf23a168eb535971501.vtt",
  "transcript_text": " Hi everyone, my name is Yousef. Yeah, so I'm a cryptographer at ConsenSys working on Gnark, the zk-snark library, and Linear, the zk-evm. And today I'm going gonna talk about elliptic curves on snarks. So I have two problems in my life. One, getting my wife to choose a restaurant, difficult one. And two, Ethereum supports only BN254 precompiles. So today I'm gonna talk about the second problem because first one we need more time, right? So what are these BN254 precompiles so BN254 is a elliptic curve so it is this mathematical objects on which we can do some sort of cryptography and mainly these three operations that we call precompile so they are like native smart contracting ethereum so you can do addition like take two points and add them, have a third point. And you can do scalar multiplication, which is if you multiply a scalar by a point. So you get another point, which is like adding the points and times to itself, and the scalar. And pairing product check, where you have some billionaire map that takes points on elliptic curves, output them on some line, some extension field, and multiplies these and check if it is one. So I'm not going to talk in detail about these operations, but you can look at the illustrations and pretend you got it. So what is most important is what is is useful for doing snag verification on Ethereum, doing BLS signature verification on Ethereum, like doing some polynomial commitment like KZG verification on Ethereum, and some vehicle trees, at least with what we have for now. And so we've talked about BN254 as an elliptic curve, but there are so many elliptic curves in the wild, and what I'm trying to explain today is why there isn't like a single silver bullet curve to rule them all. So you might have heard of BLS-2381, SECP-256, so used for ECDSA signature or Ethereum. If you change a letter, you have another curve you might have heard of ED 25519 some two chains some cycles like pasta twiddle some fancier names like job job bender snatch gramke and some new names like lollipops yeah so many names so what i want to start with is some definitions of what is past, present, and future, right? So past are curves that have been used in SNARKs, but not anymore. Present, curves that are still being used in SNARKs today. And future is curves that already exist in the wild, but not used in SNARKs just yet. So if we follow this color scheme, then yeah. So we have some green ones in the past, like MNTs or Twitter Cycles, some blue, like BLS or 2Chains, and some future purple, like Lollipops. And yeah, we see that BN is half blue, half green. That is because it is still used in Ethereum, but it's not secure anymore, or at least it doesn't have the targeted security. So to organize this mess, I propose to categorize it into three columns. So I'm calling non-pairing-friendly curves, pairing-friendly curves, and in-circuit curves. So again, this pre-compiles. I talked about pairings, but not all the elliptic curves are equipped with pairings, or at least not efficiently. And if your SNARK doesn't need pairings, so you can use the curves in the first column. If your SNARK needs pairings, then you need curves on the second column. And in-circuit curves are this kind of curves that were built in purpose to do some computations over the SNARK. Not to do the SNARK, but just, I don't know, you want to prove some signature with a SNARK, then maybe building an efficient elliptic curve would help you. So if we take a closer look to the first column, so we have, for example, SNARKs like Bulletproofs or Halo or Nova, they can use the curves from the first column. But then the question is, why there isn't a single curve? Well, it depends on what you want. If you want performance, then maybe ED25519 is the best curve. If you want standard, maybe the next curve. If you're scared of NIST, maybe you choose another standard like Bitcoin or Ethereum curve, like SICP. If you want a recursion, that is, you want to do a proof of a proof, then maybe you can use SICU if you want compatibility with SICP. If you do not care about compatibility, you just want performance, then Twitter. If you want more performance, then PASTA. If you want hybrid recursion, that is a SNARK from the first column and a SNARK in the second column, then maybe Pluto-Aries or Gramkin, BN if you want compatibility with Ethereum. What about the second column? So the second column is for SNARKs that are pairing-based. Those are like GOT16 or anything that is based on KZG, like Planck, for instance. So you can use any curve in the second column. And then, again, why there isn't a single curve if you want Ethereum compatibility then BN if you want performance BLS12 if you want one recursion that is a proof of a proof maybe you want to use two chains if you want infinite recursion with pairing base so you have stuck with MNTs but these are slow either slow or secure if you had some hybrid recursion then you can also have other propositions here. So the last column is so for example if you want to prove some signatures like EDDSA or ECDSA or some specific hashes on elliptic curves or some vertical trees then you can choose from this third column but then again if you want just elliptic curve cryptography you might want to use job, if you want just elliptic curve cryptography, you might want to use job-job. If you want faster elliptic curve cryptography, maybe bandersnatch. If you want pairing-based cryptography, then you need, for example, two chains or cycles, then BW6 or MNT. Either you want one recursion or infinite recursion. If you want to mix things and make them succinctness, maybe the lollipops if you want to make them compatible with bn then maybe gramcane so this is why we do not have like a single elliptic curve but on ethereum we have a single elliptic curve so what i want to talk about next is the story so far so goldwasser micali and wacko they invented zero knowledge rules and there have been a lot of papers, both on the practical side and the theoretical side since. Yeah, a lot. But what I want to focus on is pairing-based SNARKs, because those constructions, they were based on different assumptions, and even those that were based on elliptic curves, we didn't care about which elliptic curves, because we can take any one. But starting with pairing-based, we started constructing elliptic curves in purpose for SNARCs. And for me, the turning point was this paper by Bonego and Nissim. It has nothing to do with SNARCs. It is a doubly homomorphic encryption scheme. That is, you can do any additions you want on the ciphertext and a single multiplication on the ciphertext. But it wasn't practical, and this is because for the decryption we needed to solve a discrete logarithm problem. So not practical. But fortunately, so researchers like Grossig, Gortz, Ostrovsky, and Sahai, between 2006 until 2010, they built on top of this idea of W homomorphic encryption because they said, well, it's not practical, but maybe in ZKPs we do not need to do decryption. We just need some sort of a commitment. Then maybe we can ditch decryption and we can have zero-knowledge truth. And they did this. But we didn't have implementation at that point. And the turning point implementation-wise was this paper by Gennaro et al. They propose insightful constructions for polynomial commitments. And mixing this with the pairing-based papers, pairing-based SNARK papers, well, we started having implementation. And the first implementation I'm aware of is this paper called Pinocchio. and when I looked at the code it was proprietary still now but they used our BN256 curve from another paper in 2010 by Nariga Hall and it was it had the 128 bit security at that time and two ADCT 5 so the term was not coined to ADCT at that time but it just means for now like let's say, a performance metric. A few months later, there was this paper, Parni, where they implemented BST side license Pinocchio with another elliptic curve, BN254, from another paper in 2010. And it has a 2-addicity 45 at that time, even if we didn't know about what is 2-ADCT is for. So same year, so Ben Sasson, Chiesa, and others, they implemented Pinocchio, a variant, and they used a very specific elliptic code that I'm calling GMV6183. It is due to a paper to Galbraith, McKee, and Valensan. The implementation is still there today in LibFF. It has a 2-ADCT 31. The 2-ADCT notion was introduced in this paper, but it had a security 80-bit. So it is like, for those who know, it's just like an MNT curve, but with a cofactor equal to 4, so that they have like a twisted Edward form. So next year, pretty much the same authors, they proposed the BN, the famous BN254 curve, the curve that we are using today in Ethereum. And what they wanted is a two-addicity term. I mean, BN curves were used in pairing-based cryptography, but in Snarks, they wanted a two-addicity. So they constructed this curve with two-addicityicity-28, but my question is why didn't use the curve from pantry which has already a 45-2-oddicity and both on the prime field, the base field and the scalar field. And yeah, I mean implementation wise the one that we have today in Ethereum is ugly especially when you construct the tower and this one was pretty much simple. But yeah, pairings were used in cryptography and so the researchers have been working on the cryptanalysis of pairing but the turning point cryptanalysis wise was this paper by Kim and Barbulescu. So they found a new complexity for solving this crypt logarithm problem over extension field. But to give proper credit, it was this paper in 2016, same year, by Meneses, Sarkar, and Singh, where they analyzed the conclusion, I mean, the impact of this Kim and Barberley School paper on the choice of elliptic curves. And in their conclusion, they proposed using BLS-12 curve. And for the record, BLS-12, there were curves from 2001 and BN from 2005. And few people cared about BLS12 because of BN. But because of this paper, we came back to BLS12. And I believe based on that, Fox, Zika, especially, they proposed the famous BLS12381 that we're going to have now in Pektra, upgrading Ethereum. Now, if you want like recursion you need two curves this is what we call two cycle so you need two curves because to to express things efficiently in recursion you need the curves to share some parameters and it was this famous paper scalable zero knowledge via cycles of elliptic curvesves, by Ben Sasson et al., that proposed the first practical setting for recursion, and they devised the MNT4289 and 298 and MNT6298. It has low security, big adhicity, and they also found another cycle, but they updated the paper only in 2020 on Eprint, six years later, I'm sorry, but they shared the parameters with Coda folks, now Mina, and Mina used this at some point. So it is a paper from 2001, the construction of the elliptic curve, due to Miyajima, Kawayashi, and Takano, but just to give proper credit again again so it was a paper of 2008 by Karabina and Teske who established for the first time that MNT4 and MNT6 form a two cycle and yeah so because of security we need big parameters and it was Oror Gievic who gave I think the biggest one so far of size 992 so it is not practical I mean it's it's slow but yeah for research it's there but the to addicity is small and it's very difficult to find a higher security with higher at the city M&T cycles but I think two weeks ago Costello and Korpahl they proposed this paper lollipops of pair infinitely elliptic curves and they solved the problem of higher to addicity for MNT cycles and the idea was pretty much clever they took the MNT cycles I mean the problem with MNT cycles is like you need to solve this pair generalized spell equation and to increase your search space you need to increase the discrete some discrimin you need to increase some discriminants. And the bigger the discriminants, the harder it is to find the curves. Let's put it like this. And what they did is like they took MNTs and they used some super singular elliptic curves with some other algorithm called Borica. And it works, but it is still slow, so it's not practical. And also Santos, Costello, and Naik, they looked at cycles of peri-infant not elliptic curves, but curves in general, and they proposed some mix of elliptic curves, ordinary, super singular, and also some hyper-elliptic curves. So it is as slow as MNT, as far as I can tell, and also it is still early research. So implementation-wise, it's going to be difficult to do like this a billion varieties implementations efficiently now if you want just recursion but not infinite recursion you just need to do a proof of a proof maybe just for aggregation you need two chains so there is this famous paper called Xexi they introduced this curve called BLS2F377 which is used I think in Alio and in Celo and others blockchains and some Cox-Pinch 6 curve in I think 2020 on Eprint at least and same year we proposed another so with another BW6 curve that was more efficient and we generalize this to some other to any elliptical and families but it was just research implementation wise these two curves are like BLS2F and BW6 are the most efficient nowadays for two chains but it wasn't Zexi that introduced the notion of two chains it was five years ago but hidden in some appendix of the paper, Geppetto. So they used the same BN254 curve from Pinocchio, and they built on top of it a BW6 curve, giving the raise to the first implementation of two chain. Yeah, but it was hidden in some appendix. Now, if you want to do a recursion without pairing-friendly snarks, to do a recursion without pairing pairing friendly snacks you just need recursion of some other snacks that do not need bearings then you can use the plane cycles so in the halo paper they introduced the twiddledy to the bone to the d2 cycle and they then they are placed it with pasta which is more efficient And it is used now in Halo 2 implementation. It is used in folding schemes like in the Sonobi implementation. But it was a year before that at least I've seen a two-cycle in the zero-knowledge setting. It was proposed in this website by Andrew Prostra, and it is the SecP-SecU curve, and in his mail he gave the parameters. So for me it was the first one in the zero-knowledge setting. But research-wise, it was in 2011, it was called amicable pairs under adequate cycles, and the Halo paper cites this one actually but actually I was able to find an implementation of plane 2 cycles back to 2007 in a different context for primality testing like when you test primes you can test them with elliptic curves and it was François Morin, his implementation here where he was discarding these plane cycles because they were bad for primality testing and the same year the definition was formalized in this paper by B. Mihailovsky it's called dual elliptic primes so dual elliptic primes amicable pairs aliquot cycles and plane cycles they are all the same thing and I think two weeks two months ago no this this summer I mean this year so Antoine Jou and others they looked at elliptic curves that form cycle from a mathematical point of view and they're calling it elliptic curves over Haas pairs so all of these the same thing and if you want to mix then snark-based, pairing-based snarks and non-pairing-based snarks, you can use hybrid two cycles. So one of them is proposed by Daira Hopu from Zcash. So this is the one. And actually, I was able to find another implementation with BN381 in MINA protocol by Zach Meckler, but I don't think it was used anywhere. It was just experimental. And then if you want compatibility with Ethereum, so Aztec proposed the Gramkin curve that is compatible with BN254 from Ethereum. But actually, I mean, you can take any prime order pairing friendly ellipticals and by definition you can construct a hybrid cycle. And if you want to merge all of these like you want to do a cycle on the two chain so we call it lollipops like you can have a cycle and then a stick it can be pairing friendly it can be non pairing friendly it depends on your use. But together with Antonio Sanso from EF, we proposed a way to build families of, like, when you have a pairing-friendly elliptic curve and on top of it you can have a plane cycle. And then, I think, a couple of days after our paper, Generalized our idea with some other families of curves like KSS. And then, I think, one week ago, on ePrint at least, Aurore and Simon Masson, they proposed an even more general way to construct those lollipops with fixing the curve. Before we couldn't fix the curve, we had to construct all the curves together, but they were able to construct it on, for example, BLS381, for instance. And yeah, then lollipops, they found another way to do the lollipops with all the curves being pairing friendly. It wasn't possible at this point, but they did it with super singular elliptic curves, which are defined over extensions, so make things a bit more slow. Yeah, that's it for me. So many information, but yeah. Thank you. Thank you very much. Very nice, good overview, covered a lot of stuff. There's a few questions, I think two. One that kind of leads into the other, so maybe I can read out to you. So, yeah, I think one that was asked even before the talk started, so I think you have a fan who's wondering, what is the future of curve-based snarks compared to hash-based snarks? I was expecting this question, by the way. I mean, yeah, hash-based snarks, they are fast because you can construct them over smaller fields, so you can speed up things. But I still believe that curve-based snarks, they come with succinctness, so there is like a place for both. And today we see that, for example, for ZKVMs or ZKEVMs, they do a lot of stark proving, so hash-based SNARKs. But then at the end of the day, they compose it or they wrap it with a curve-based SNARK so that they can get Ethereum compatibility one and they can get success, which is like proofs are small. So I think, I believe both are to stay. Good. Then, so do you think recursive SNARK into STARK might present an interest to be post-quantum? Here, SNARK cannot be simulated by post-quantum computer. How SNARK and STARK benches, benchmarks? Okay, so let me try to understand the question. You can pose, yeah. So I think, yes, SNARKs, if we're saying that SNARKs are based on curves, which is not really the case, but I understand it like this. Well, if it is based on curves, it's not post-quantum. STARKs, well, if they are based on hashes, they are plausibly post-quantum. Composing both means that the protocol is not post-quantum. But yeah, if you want post-quantum resistance, then definitely anything that is hash-based. I mean, yeah, you can also talk about isogenies, because these are like curves-based. These are post-quantum, but I'm not aware of any isogeny-based snarks yet. And so I think then the last part of the question, how do they sort of benchmark against each other in terms of efficiency? Yeah, so it depends really on what baseline we're benchmarking against. So it really depends, but for example, if we are taking any... So SNARKs, they work over big fields defined by the elliptic curve. So if we define the statements over this field natively, then it's competitive. But in STOCKs, you can define them over any field. And for example, if you define them over binary field, like Binus, then you can do things like K-Chalk faster. So it really depends on the baseline. Nice. Okay. Good. Some more questions came in in the meantime. We have two minutes left, so we can go into it. Sure. How important is high two-addicity? Can we get away without it? Okay, yeah. So the 2-addicity is... So in ellipticals, we're working over this subgroup of prime order, and the 2-addicity means just this order minus 1 has to be divisible by a high power of 2, and it just means FFT-friendliness, because the best way to implement FFT is like radix to FFT. And for big circuits, then you definitely need this two-adicity. For small circuits, maybe you can get away with smoothness, like just some smooth integers dividing like p minus one. But yeah, for big circuit, like for example, I work on the linear ZKVM. We work on big circuits. So yeah, it's definitely a requirement for us. And why do you want to get away without it? I'm sorry, why? I'm just asking my follow-on, like from my own understanding, why do you want to get away without it? Like what problems does it introduce? Yeah, so it introduces the fact From my own understanding, why do you want to get away without it? What problems does it introduce? Yes, so it introduces the fact that you need a specific elliptic curve. For example, if I'm talking about Ethereum, so Ethereum curve, so the R-1 is divisible by high power of 2, but the P-1 is not. So if you want to do, for example, a recursion of Ethereum, it wouldn't work on the second layer. Yes, yes, Yes, of course. Good. Then last question while we have 30 seconds left. Why is it crucial for recursion to have two curves where one is prime and the other, one prime is the order of the other? Yes. So we express the statement of whatever we want to prove on the subgroup of the elliptic curve. And if we want to do a proof of a proof, we need to do the verification as a statement. But the verification uses these pairings, and pairings are defined over a different field. So if you want to do pairings in the subgroup, you need the field of the pairing to match the field of your subgroup so that computations are native. Otherwise you need to emulate non-native field arithmetic which is quite costly. I mean we do this but it's quite costly. But if you have native then the number of constraints or your proof generation will be way, way faster. Good. I see there are more questions, but we're actually out of time. Maybe you can catch him offline. But yeah, thank you very much. I'm thrilled with the amount of questions. Great. Thank you very much. Thank you.",
  "eventId": "devcon-7",
  "slot_start": 1731405600000,
  "slot_end": 1731407400000,
  "slot_roomId": "stage-3",
  "resources_presentation": "https://docs.google.com/presentation/d/15MaGmHzAvHj765BvqDHs0ZxiiGevi3H9hscAvkCAGTc",
  "resources_slides": null,
  "speakers": [
    "youssef-el-housni"
  ]
}